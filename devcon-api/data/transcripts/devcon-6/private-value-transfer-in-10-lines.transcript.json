{
	"systeminfo": "AVX = 1 | AVX2 = 1 | AVX512 = 0 | FMA = 1 | NEON = 0 | ARM_FMA = 0 | F16C = 1 | FP16_VA = 0 | WASM_SIMD = 0 | BLAS = 0 | SSE3 = 1 | VSX = 0 | ",
	"model": {
		"type": "base",
		"multilingual": false,
		"vocab": 51864,
		"audio": {
			"ctx": 1500,
			"state": 512,
			"head": 8,
			"layer": 6
		},
		"text": {
			"ctx": 448,
			"state": 512,
			"head": 8,
			"layer": 6
		},
		"mels": 80,
		"f16": 1
	},
	"params": {
		"model": "models/ggml-base.en.bin",
		"language": "en",
		"translate": false
	},
	"result": {
		"language": "en"
	},
	"transcription": [
		{
			"timestamps": {
				"from": "00:00:00,000",
				"to": "00:00:13,000"
			},
			"offsets": {
				"from": 0,
				"to": 13000
			},
			"text": " [ Music ]"
		},
		{
			"timestamps": {
				"from": "00:00:13,000",
				"to": "00:00:18,960"
			},
			"offsets": {
				"from": 13000,
				"to": 18960
			},
			"text": " I'm Maxine Beznoff and I'm a software engineer/language designer here at Aztec Network"
		},
		{
			"timestamps": {
				"from": "00:00:18,960",
				"to": "00:00:21,500"
			},
			"offsets": {
				"from": 18960,
				"to": 21500
			},
			"text": " and I'm going to be introducing you to Noire today."
		},
		{
			"timestamps": {
				"from": "00:00:21,500",
				"to": "00:00:27,200"
			},
			"offsets": {
				"from": 21500,
				"to": 27200
			},
			"text": " Noire is our Rust-based domain-specific language for writing zero-knowledge circuits."
		},
		{
			"timestamps": {
				"from": "00:00:27,840",
				"to": "00:00:31,500"
			},
			"offsets": {
				"from": 27840,
				"to": 31500
			},
			"text": " I'm going to walk you through a basic circuit and then also show you how to go"
		},
		{
			"timestamps": {
				"from": "00:00:31,500",
				"to": "00:00:34,540"
			},
			"offsets": {
				"from": 31500,
				"to": 34540
			},
			"text": " about proving and verifying that circuit in TypeScript."
		},
		{
			"timestamps": {
				"from": "00:00:34,540",
				"to": "00:00:38,400"
			},
			"offsets": {
				"from": 34540,
				"to": 38400
			},
			"text": " So first I want to talk about what actually makes Noire unique."
		},
		{
			"timestamps": {
				"from": "00:00:38,400",
				"to": "00:00:44,080"
			},
			"offsets": {
				"from": 38400,
				"to": 44080
			},
			"text": " Noire aims to be more flexible in its design than other domain-specific languages"
		},
		{
			"timestamps": {
				"from": "00:00:44,080",
				"to": "00:00:45,460"
			},
			"offsets": {
				"from": 44080,
				"to": 45460
			},
			"text": " that currently exist out there."
		},
		{
			"timestamps": {
				"from": "00:00:45,460",
				"to": "00:00:50,560"
			},
			"offsets": {
				"from": 45460,
				"to": 50560
			},
			"text": " And we do this by rather than compiling to a specific NP-complete language,"
		},
		{
			"timestamps": {
				"from": "00:00:50,560",
				"to": "00:00:53,320"
			},
			"offsets": {
				"from": 50560,
				"to": 53320
			},
			"text": " we're compiling down to an intermediate representation."
		},
		{
			"timestamps": {
				"from": "00:00:53,320",
				"to": "00:00:57,040"
			},
			"offsets": {
				"from": 53320,
				"to": 57040
			},
			"text": " We call this intermediate representation the abstract circuit."
		},
		{
			"timestamps": {
				"from": "00:00:57,120",
				"to": "00:01:01,920"
			},
			"offsets": {
				"from": 57120,
				"to": 61920
			},
			"text": " Intermediate representation or the Acer as I'm going to refer to it throughout this talk."
		},
		{
			"timestamps": {
				"from": "00:01:01,920",
				"to": "00:01:09,360"
			},
			"offsets": {
				"from": 61920,
				"to": 69360
			},
			"text": " This IR can then be compiled down to rank one constraint system or Plonkish languages,"
		},
		{
			"timestamps": {
				"from": "00:01:09,360",
				"to": "00:01:10,760"
			},
			"offsets": {
				"from": 69360,
				"to": 70760
			},
			"text": " whichever you so choose."
		},
		{
			"timestamps": {
				"from": "00:01:10,760",
				"to": "00:01:16,800"
			},
			"offsets": {
				"from": 70760,
				"to": 76800
			},
			"text": " This is analogous to the LLVM IR but rather than converting down the IR"
		},
		{
			"timestamps": {
				"from": "00:01:16,800",
				"to": "00:01:21,900"
			},
			"offsets": {
				"from": 76800,
				"to": 81900
			},
			"text": " to a specific instruction set architecture, we're compiling down to the constraint system"
		},
		{
			"timestamps": {
				"from": "00:01:21,900",
				"to": "00:01:23,800"
			},
			"offsets": {
				"from": 81900,
				"to": 83800
			},
			"text": " of a given ZK-proof construction."
		},
		{
			"timestamps": {
				"from": "00:01:24,340",
				"to": "00:01:30,740"
			},
			"offsets": {
				"from": 84340,
				"to": 90740
			},
			"text": " This actually enables us to essentially decouple the back-end-proof system and the language."
		},
		{
			"timestamps": {
				"from": "00:01:30,740",
				"to": "00:01:36,760"
			},
			"offsets": {
				"from": 90740,
				"to": 96760
			},
			"text": " We currently have one fully integrated back-end system and that's Aztec's Brettenberg library."
		},
		{
			"timestamps": {
				"from": "00:01:36,760",
				"to": "00:01:41,940"
			},
			"offsets": {
				"from": 96760,
				"to": 101940
			},
			"text": " And we also have plans for integrations with the ArcWorks proving system such as Marlin"
		},
		{
			"timestamps": {
				"from": "00:01:41,940",
				"to": "00:01:46,660"
			},
			"offsets": {
				"from": 101940,
				"to": 106660
			},
			"text": " and Groth 16 but anyone, if you can compile it down to whatever you'd like."
		},
		{
			"timestamps": {
				"from": "00:01:46,660",
				"to": "00:01:53,540"
			},
			"offsets": {
				"from": 106660,
				"to": 113540
			},
			"text": " This to our knowledge is the only DSL that currently has fully integrated proving system optimizations."
		},
		{
			"timestamps": {
				"from": "00:01:53,900",
				"to": "00:01:58,140"
			},
			"offsets": {
				"from": 113900,
				"to": 118140
			},
			"text": " So rather than just having an interface for language system optimizations,"
		},
		{
			"timestamps": {
				"from": "00:01:58,140",
				"to": "00:02:00,820"
			},
			"offsets": {
				"from": 118140,
				"to": 120820
			},
			"text": " we actually have it on the proving system as well."
		},
		{
			"timestamps": {
				"from": "00:02:00,820",
				"to": "00:02:03,800"
			},
			"offsets": {
				"from": 120820,
				"to": 123800
			},
			"text": " But like where do we actually get from this?"
		},
		{
			"timestamps": {
				"from": "00:02:03,800",
				"to": "00:02:12,540"
			},
			"offsets": {
				"from": 123800,
				"to": 132540
			},
			"text": " So we now, different use cases require different kinds of systems and now we actually have a language"
		},
		{
			"timestamps": {
				"from": "00:02:12,540",
				"to": "00:02:16,720"
			},
			"offsets": {
				"from": 132540,
				"to": 136720
			},
			"text": " that separates the middle end, front end middle end and back end of a language"
		},
		{
			"timestamps": {
				"from": "00:02:16,720",
				"to": "00:02:20,360"
			},
			"offsets": {
				"from": 136720,
				"to": 140360
			},
			"text": " and developers can then converge on a common architecture standard."
		},
		{
			"timestamps": {
				"from": "00:02:21,080",
				"to": "00:02:26,040"
			},
			"offsets": {
				"from": 141080,
				"to": 146040
			},
			"text": " The fact that Noir has the ability to support proving system optimizations enables us"
		},
		{
			"timestamps": {
				"from": "00:02:26,040",
				"to": "00:02:28,740"
			},
			"offsets": {
				"from": 146040,
				"to": 148740
			},
			"text": " to have the addition of optimized black box functions."
		},
		{
			"timestamps": {
				"from": "00:02:28,740",
				"to": "00:02:35,620"
			},
			"offsets": {
				"from": 148740,
				"to": 155620
			},
			"text": " A few that we have are listed right there but if a back-end system has integrated"
		},
		{
			"timestamps": {
				"from": "00:02:35,620",
				"to": "00:02:38,880"
			},
			"offsets": {
				"from": 155620,
				"to": 158880
			},
			"text": " that specific black box function, the front end can then access it."
		},
		{
			"timestamps": {
				"from": "00:02:38,880",
				"to": "00:02:42,720"
			},
			"offsets": {
				"from": 158880,
				"to": 162720
			},
			"text": " The ultimate goal here is to lower the barrier to circuit development"
		},
		{
			"timestamps": {
				"from": "00:02:42,720",
				"to": "00:02:48,240"
			},
			"offsets": {
				"from": 162720,
				"to": 168240
			},
			"text": " by incorporating cryptographic safety into the language itself while maintaining performance."
		},
		{
			"timestamps": {
				"from": "00:02:48,520",
				"to": "00:02:51,560"
			},
			"offsets": {
				"from": 168520,
				"to": 171560
			},
			"text": " So I'm mainly going to be talking about how to prove and verify in TypeScript."
		},
		{
			"timestamps": {
				"from": "00:02:51,560",
				"to": "00:02:57,200"
			},
			"offsets": {
				"from": 171560,
				"to": 177200
			},
			"text": " This very high level compilation overview also shows our package manager Nargo"
		},
		{
			"timestamps": {
				"from": "00:02:57,200",
				"to": "00:03:01,200"
			},
			"offsets": {
				"from": 177200,
				"to": 181200
			},
			"text": " that I specifically want to note that allows for proving and verifying circuits."
		},
		{
			"timestamps": {
				"from": "00:03:01,200",
				"to": "00:03:05,760"
			},
			"offsets": {
				"from": 181200,
				"to": 185760
			},
			"text": " This is very similar to cargo so you can build your circuits using this"
		},
		{
			"timestamps": {
				"from": "00:03:05,760",
				"to": "00:03:10,480"
			},
			"offsets": {
				"from": 185760,
				"to": 190480
			},
			"text": " but because to actually prove you have to require requires a proof system,"
		},
		{
			"timestamps": {
				"from": "00:03:10,480",
				"to": "00:03:14,240"
			},
			"offsets": {
				"from": 190480,
				"to": 194240
			},
			"text": " you see that line on the top going all the way over to the proof system as well"
		},
		{
			"timestamps": {
				"from": "00:03:14,240",
				"to": "00:03:16,920"
			},
			"offsets": {
				"from": 194240,
				"to": 196920
			},
			"text": " in order to compile Nargo, you need all integrated."
		},
		{
			"timestamps": {
				"from": "00:03:17,440",
				"to": "00:03:20,240"
			},
			"offsets": {
				"from": 197440,
				"to": 200240
			},
			"text": " So now I'm actually going to take you through what a Noir circuit looks like"
		},
		{
			"timestamps": {
				"from": "00:03:20,240",
				"to": "00:03:22,760"
			},
			"offsets": {
				"from": 200240,
				"to": 202760
			},
			"text": " and I'm going to use one of the most common examples"
		},
		{
			"timestamps": {
				"from": "00:03:22,760",
				"to": "00:03:25,880"
			},
			"offsets": {
				"from": 202760,
				"to": 205880
			},
			"text": " where ZK proofs are used to enable private transfers."
		},
		{
			"timestamps": {
				"from": "00:03:25,880",
				"to": "00:03:30,160"
			},
			"offsets": {
				"from": 205880,
				"to": 210160
			},
			"text": " And rather than simply showing you the entire circuit at once,"
		},
		{
			"timestamps": {
				"from": "00:03:30,160",
				"to": "00:03:32,640"
			},
			"offsets": {
				"from": 210160,
				"to": 212640
			},
			"text": " I'm going to walk through kind of each part of the circuit"
		},
		{
			"timestamps": {
				"from": "00:03:32,640",
				"to": "00:03:37,920"
			},
			"offsets": {
				"from": 212640,
				"to": 217920
			},
			"text": " and this is to highlight Noir's unique features and also for those who may be unfamiliar"
		},
		{
			"timestamps": {
				"from": "00:03:37,920",
				"to": "00:03:41,000"
			},
			"offsets": {
				"from": 217920,
				"to": 221000
			},
			"text": " with how to write a private transfer circuit, how that may be done."
		},
		{
			"timestamps": {
				"from": "00:03:41,000",
				"to": "00:03:44,640"
			},
			"offsets": {
				"from": 221000,
				"to": 224640
			},
			"text": " If you're already kind of familiar with it, you may have deduced from the inputs"
		},
		{
			"timestamps": {
				"from": "00:03:45,040",
				"to": "00:03:48,600"
			},
			"offsets": {
				"from": 225040,
				"to": 228600
			},
			"text": " that the circuit essentially boils down to a Merkle membership proof."
		},
		{
			"timestamps": {
				"from": "00:03:48,600",
				"to": "00:03:53,320"
			},
			"offsets": {
				"from": 228600,
				"to": 233320
			},
			"text": " Similar to how Noir's rust base, the syntax is rust-like as well."
		},
		{
			"timestamps": {
				"from": "00:03:53,320",
				"to": "00:03:56,920"
			},
			"offsets": {
				"from": 233320,
				"to": 236920
			},
			"text": " But the main thing to note here is the usage of the pub keyword."
		},
		{
			"timestamps": {
				"from": "00:03:56,920",
				"to": "00:03:59,960"
			},
			"offsets": {
				"from": 236920,
				"to": 239960
			},
			"text": " All inputs to the Noir circuit are going to be private by default"
		},
		{
			"timestamps": {
				"from": "00:03:59,960",
				"to": "00:04:05,000"
			},
			"offsets": {
				"from": 239960,
				"to": 245000
			},
			"text": " and that keyword allows you to then say this also has to be supplied to the verifier as well."
		},
		{
			"timestamps": {
				"from": "00:04:05,000",
				"to": "00:04:08,960"
			},
			"offsets": {
				"from": 245000,
				"to": 248960
			},
			"text": " Currently anything outputted from the function must also be public."
		},
		{
			"timestamps": {
				"from": "00:04:08,960",
				"to": "00:04:12,640"
			},
			"offsets": {
				"from": 248960,
				"to": 252640
			},
			"text": " And to take note of our native data type that's called the field,"
		},
		{
			"timestamps": {
				"from": "00:04:13,680",
				"to": "00:04:17,840"
			},
			"offsets": {
				"from": 253680,
				"to": 257840
			},
			"text": " this is in the Aztec-Brettenberg backend, a field on the BN254 curve."
		},
		{
			"timestamps": {
				"from": "00:04:17,840",
				"to": "00:04:23,320"
			},
			"offsets": {
				"from": 257840,
				"to": 263320
			},
			"text": " But we also support smaller data types such as U32, U8, you can even have U3."
		},
		{
			"timestamps": {
				"from": "00:04:23,320",
				"to": "00:04:27,400"
			},
			"offsets": {
				"from": 263320,
				"to": 267400
			},
			"text": " But these are less efficient as they require range constraints."
		},
		{
			"timestamps": {
				"from": "00:04:27,400",
				"to": "00:04:30,600"
			},
			"offsets": {
				"from": 267400,
				"to": 270600
			},
			"text": " And but that's all to the needs of the circuit developer."
		},
		{
			"timestamps": {
				"from": "00:04:30,600",
				"to": "00:04:35,200"
			},
			"offsets": {
				"from": 270600,
				"to": 275200
			},
			"text": " If you want to constrain using our data types rather than directly in the circuit yourself."
		},
		{
			"timestamps": {
				"from": "00:04:35,200",
				"to": "00:04:37,800"
			},
			"offsets": {
				"from": 275200,
				"to": 277800
			},
			"text": " Now we can actually get into the logic of the circuit"
		},
		{
			"timestamps": {
				"from": "00:04:37,800",
				"to": "00:04:40,720"
			},
			"offsets": {
				"from": 277800,
				"to": 280720
			},
			"text": " and we're going to start off by using two of our standard library functions."
		},
		{
			"timestamps": {
				"from": "00:04:41,200",
				"to": "00:04:43,560"
			},
			"offsets": {
				"from": 281200,
				"to": 283560
			},
			"text": " The Schnorr fixed base scalar multiplication method."
		},
		{
			"timestamps": {
				"from": "00:04:43,560",
				"to": "00:04:48,400"
			},
			"offsets": {
				"from": 283560,
				"to": 288400
			},
			"text": " So we can construct a private public key from the private key that was supplied to the circuit."
		},
		{
			"timestamps": {
				"from": "00:04:48,400",
				"to": "00:04:53,080"
			},
			"offsets": {
				"from": 288400,
				"to": 293080
			},
			"text": " And then also a Patterson hash function, which is going to take in a list of field elements"
		},
		{
			"timestamps": {
				"from": "00:04:53,080",
				"to": "00:04:56,280"
			},
			"offsets": {
				"from": 293080,
				"to": 296280
			},
			"text": " and return a point on the BN254 curve."
		},
		{
			"timestamps": {
				"from": "00:04:56,280",
				"to": "00:05:01,120"
			},
			"offsets": {
				"from": 296280,
				"to": 301120
			},
			"text": " We first use the random input secret that was shown in the previous slide"
		},
		{
			"timestamps": {
				"from": "00:05:01,120",
				"to": "00:05:05,680"
			},
			"offsets": {
				"from": 301120,
				"to": 305680
			},
			"text": " to keep our note commitment private and not associated with any one account."
		},
		{
			"timestamps": {
				"from": "00:05:05,680",
				"to": "00:05:09,080"
			},
			"offsets": {
				"from": 305680,
				"to": 309080
			},
			"text": " Once again, this is using the Aztec-Brettenberg backend."
		},
		{
			"timestamps": {
				"from": "00:05:09,080",
				"to": "00:05:13,480"
			},
			"offsets": {
				"from": 309080,
				"to": 313480
			},
			"text": " But if a backend supports these functions, then the front end can access it."
		},
		{
			"timestamps": {
				"from": "00:05:13,480",
				"to": "00:05:16,040"
			},
			"offsets": {
				"from": 313480,
				"to": 316040
			},
			"text": " And now we actually have the meat of the circuit"
		},
		{
			"timestamps": {
				"from": "00:05:16,040",
				"to": "00:05:18,680"
			},
			"offsets": {
				"from": 316040,
				"to": 318680
			},
			"text": " where we're first going to generate a nullifier."
		},
		{
			"timestamps": {
				"from": "00:05:18,680",
				"to": "00:05:20,720"
			},
			"offsets": {
				"from": 318680,
				"to": 320720
			},
			"text": " And this nullifier has to be unique."
		},
		{
			"timestamps": {
				"from": "00:05:20,720",
				"to": "00:05:22,720"
			},
			"offsets": {
				"from": 320720,
				"to": 322720
			},
			"text": " And this is used to prevent double spends."
		},
		{
			"timestamps": {
				"from": "00:05:22,720",
				"to": "00:05:28,400"
			},
			"offsets": {
				"from": 322720,
				"to": 328400
			},
			"text": " And the circuit, the contract that integrates the circuit is going to have to make sure make sure of that."
		},
		{
			"timestamps": {
				"from": "00:05:28,400",
				"to": "00:05:34,120"
			},
			"offsets": {
				"from": 328400,
				"to": 334120
			},
			"text": " Where we provide the note commitment that we just calculated in the previous in the previous slide."
		},
		{
			"timestamps": {
				"from": "00:05:34,120",
				"to": "00:05:36,760"
			},
			"offsets": {
				"from": 334120,
				"to": 336760
			},
			"text": " The index of this note commitment in the Merkle tree."
		},
		{
			"timestamps": {
				"from": "00:05:36,760",
				"to": "00:05:40,720"
			},
			"offsets": {
				"from": 336760,
				"to": 340720
			},
			"text": " And then the private key to act as that identity differentiator."
		},
		{
			"timestamps": {
				"from": "00:05:40,720",
				"to": "00:05:45,680"
			},
			"offsets": {
				"from": 340720,
				"to": 345680
			},
			"text": " And then finally, we have a check membership function that's going to take in the hash path,"
		},
		{
			"timestamps": {
				"from": "00:05:45,680",
				"to": "00:05:48,800"
			},
			"offsets": {
				"from": 345680,
				"to": 348800
			},
			"text": " the index, that note commitment and a note root."
		},
		{
			"timestamps": {
				"from": "00:05:48,800",
				"to": "00:05:52,880"
			},
			"offsets": {
				"from": 348800,
				"to": 352880
			},
			"text": " It's going to calculate a note root using the hash path and commitment provided."
		},
		{
			"timestamps": {
				"from": "00:05:52,880",
				"to": "00:05:58,520"
			},
			"offsets": {
				"from": 352880,
				"to": 358520
			},
			"text": " And if it matches the note root there that we provided from the circuit, which is public,"
		},
		{
			"timestamps": {
				"from": "00:05:58,520",
				"to": "00:06:05,520"
			},
			"offsets": {
				"from": 358520,
				"to": 365520
			},
			"text": " we then know, OK, that this note commitment that was calculated within the circuit is actually"
		},
		{
			"timestamps": {
				"from": "00:06:06,520",
				"to": "00:06:10,600"
			},
			"offsets": {
				"from": 366520,
				"to": 370600
			},
			"text": " the person proving it does possess that note commitment."
		},
		{
			"timestamps": {
				"from": "00:06:10,600",
				"to": "00:06:14,520"
			},
			"offsets": {
				"from": 370600,
				"to": 374520
			},
			"text": " And finally, we return our nullifier and our recipient."
		},
		{
			"timestamps": {
				"from": "00:06:14,520",
				"to": "00:06:18,880"
			},
			"offsets": {
				"from": 374520,
				"to": 378880
			},
			"text": " This is actually constraining these two values with the outputs."
		},
		{
			"timestamps": {
				"from": "00:06:18,880",
				"to": "00:06:22,280"
			},
			"offsets": {
				"from": 378880,
				"to": 382280
			},
			"text": " It's a little syntactic sugar that we have for our return values."
		},
		{
			"timestamps": {
				"from": "00:06:22,280",
				"to": "00:06:27,800"
			},
			"offsets": {
				"from": 382280,
				"to": 387800
			},
			"text": " You could instead, for example, not have the nullifier be returned as public output."
		},
		{
			"timestamps": {
				"from": "00:06:27,800",
				"to": "00:06:32,280"
			},
			"offsets": {
				"from": 387800,
				"to": 392280
			},
			"text": " You could instill supply as public input and you would have to then write constrain"
		},
		{
			"timestamps": {
				"from": "00:06:32,280",
				"to": "00:06:35,720"
			},
			"offsets": {
				"from": 392280,
				"to": 395720
			},
			"text": " like nullifier hash equals nullifier index zero there."
		},
		{
			"timestamps": {
				"from": "00:06:36,080",
				"to": "00:06:40,000"
			},
			"offsets": {
				"from": 396080,
				"to": 400000
			},
			"text": " But this is happening implicitly when we return it from the circuit right there."
		},
		{
			"timestamps": {
				"from": "00:06:40,000",
				"to": "00:06:46,840"
			},
			"offsets": {
				"from": 400000,
				"to": 406840
			},
			"text": " As the circuit, as the title of this presentation is, it's noir private transfer in 10 lines."
		},
		{
			"timestamps": {
				"from": "00:06:46,840",
				"to": "00:06:50,240"
			},
			"offsets": {
				"from": 406840,
				"to": 410240
			},
			"text": " So we don't really show a lot of what the noir syntax looks like."
		},
		{
			"timestamps": {
				"from": "00:06:50,240",
				"to": "00:06:53,880"
			},
			"offsets": {
				"from": 410240,
				"to": 413880
			},
			"text": " So I wanted to quickly highlight what else also exists in noir."
		},
		{
			"timestamps": {
				"from": "00:06:53,880",
				"to": "00:06:59,240"
			},
			"offsets": {
				"from": 413880,
				"to": 419240
			},
			"text": " We do have compound data types such as arrays, tuples and structs, as you can see right there."
		},
		{
			"timestamps": {
				"from": "00:06:59,240",
				"to": "00:07:05,320"
			},
			"offsets": {
				"from": 419240,
				"to": 425320
			},
			"text": " And you can then we also have sub modules so you can easily separate your functions as you as you see fit."
		},
		{
			"timestamps": {
				"from": "00:07:05,760",
				"to": "00:07:11,840"
			},
			"offsets": {
				"from": 425760,
				"to": 431840
			},
			"text": " Also, just recently added global constants, which you can also import as you would in any other programming language such as Rust."
		},
		{
			"timestamps": {
				"from": "00:07:11,840",
				"to": "00:07:17,520"
			},
			"offsets": {
				"from": 431840,
				"to": 437520
			},
			"text": " For control flow, we have for loops and if statements and we're looking to add recursion soon as well."
		},
		{
			"timestamps": {
				"from": "00:07:17,520",
				"to": "00:07:24,440"
			},
			"offsets": {
				"from": 437520,
				"to": 444440
			},
			"text": " We also have recently added generics, which is highlighted right here, which is a great benefit to the developer experience."
		},
		{
			"timestamps": {
				"from": "00:07:24,680",
				"to": "00:07:36,760"
			},
			"offsets": {
				"from": 444680,
				"to": 456760
			},
			"text": " Just to recap, we try and be high level as we want to make this development experience easier, but also abstract away some of that cryptographic safety that you might be familiar with in other ZK circuit languages,"
		},
		{
			"timestamps": {
				"from": "00:07:36,760",
				"to": "00:07:41,080"
			},
			"offsets": {
				"from": 456760,
				"to": 461080
			},
			"text": " or where you have to directly specify essentially every constraint."
		},
		{
			"timestamps": {
				"from": "00:07:41,080",
				"to": "00:07:47,080"
			},
			"offsets": {
				"from": 461080,
				"to": 467080
			},
			"text": " And that's the ultimate goal of noir to have safety and the greater development experience."
		},
		{
			"timestamps": {
				"from": "00:07:47,080",
				"to": "00:07:53,040"
			},
			"offsets": {
				"from": 467080,
				"to": 473040
			},
			"text": " Now, I'm actually going to kind of walk through how you would use our wrapper to prove and verify this circuit in TypeScript."
		},
		{
			"timestamps": {
				"from": "00:07:53,040",
				"to": "00:07:58,680"
			},
			"offsets": {
				"from": 473040,
				"to": 478680
			},
			"text": " And then ultimately in the browser so that you can prove on the client side."
		},
		{
			"timestamps": {
				"from": "00:07:58,680",
				"to": "00:08:08,040"
			},
			"offsets": {
				"from": 478680,
				"to": 488040
			},
			"text": " We have a noir.js package, which has been created to allow developer to you can directly compile your circuit in TypeScript as you see there."
		},
		{
			"timestamps": {
				"from": "00:08:08,040",
				"to": "00:08:16,640"
			},
			"offsets": {
				"from": 488040,
				"to": 496640
			},
			"text": " But in this package, you can also read in from the Acer from file that would be generated by the Nargo package manager."
		},
		{
			"timestamps": {
				"from": "00:08:17,000",
				"to": "00:08:23,480"
			},
			"offsets": {
				"from": 497000,
				"to": 503480
			},
			"text": " That's a choice of the developer, but in this example, we just show you how to compile it directly in TypeScript."
		},
		{
			"timestamps": {
				"from": "00:08:23,480",
				"to": "00:08:29,080"
			},
			"offsets": {
				"from": 503480,
				"to": 509080
			},
			"text": " So after we have an object representing our Acer, we then just have to specify our ABI."
		},
		{
			"timestamps": {
				"from": "00:08:29,080",
				"to": "00:08:37,160"
			},
			"offsets": {
				"from": 509080,
				"to": 517160
			},
			"text": " And the ABI is what the Prover is going to be providing to ultimately construct our proof, which has our private and public inputs."
		},
		{
			"timestamps": {
				"from": "00:08:37,160",
				"to": "00:08:41,200"
			},
			"offsets": {
				"from": 517160,
				"to": 521200
			},
			"text": " And that's going to be used to generate the witness and ultimately generate the proof."
		},
		{
			"timestamps": {
				"from": "00:08:41,480",
				"to": "00:08:47,880"
			},
			"offsets": {
				"from": 521480,
				"to": 527880
			},
			"text": " So because noir is back in diagnostic, though, we have a separate wrapper around the Aztec-Brettenberg back end."
		},
		{
			"timestamps": {
				"from": "00:08:47,880",
				"to": "00:08:52,480"
			},
			"offsets": {
				"from": 527880,
				"to": 532480
			},
			"text": " And that's any other back end that gets integrated is going to have to do the same thing as well."
		},
		{
			"timestamps": {
				"from": "00:08:52,480",
				"to": "00:09:01,720"
			},
			"offsets": {
				"from": 532480,
				"to": 541720
			},
			"text": " Because this back end has been made to match the Acer interface in order to set up the Prover and Verifier, we simply pass in the Acer as you can see right there."
		},
		{
			"timestamps": {
				"from": "00:09:01,720",
				"to": "00:09:05,640"
			},
			"offsets": {
				"from": 541720,
				"to": 545640
			},
			"text": " And then that ABI that we specified earlier to construct our proof."
		},
		{
			"timestamps": {
				"from": "00:09:05,640",
				"to": "00:09:08,080"
			},
			"offsets": {
				"from": 545640,
				"to": 548080
			},
			"text": " And then we just pass it along to our Verifier."
		},
		{
			"timestamps": {
				"from": "00:09:08,360",
				"to": "00:09:15,880"
			},
			"offsets": {
				"from": 548360,
				"to": 555880
			},
			"text": " One thing you might know, though, is that you don't see any public inputs being passed to the Verifier, even though we have that in our circuit."
		},
		{
			"timestamps": {
				"from": "00:09:15,880",
				"to": "00:09:22,160"
			},
			"offsets": {
				"from": 555880,
				"to": 562160
			},
			"text": " Currently the proof that gets spit out by Brettenberg is prepending those as 32-byte hex string inputs."
		},
		{
			"timestamps": {
				"from": "00:09:22,160",
				"to": "00:09:28,800"
			},
			"offsets": {
				"from": 562160,
				"to": 568800
			},
			"text": " But we plan to separate that as developers might like to have those inputs separated for their own development purposes."
		},
		{
			"timestamps": {
				"from": "00:09:28,800",
				"to": "00:09:34,000"
			},
			"offsets": {
				"from": 568800,
				"to": 574000
			},
			"text": " But that's just to take note of why you don't see any public inputs being passed to the Verifier there."
		},
		{
			"timestamps": {
				"from": "00:09:34,280",
				"to": "00:09:42,000"
			},
			"offsets": {
				"from": 574280,
				"to": 582000
			},
			"text": " So it's cool that we can actually verify in TypeScript, but we want to be able to also enable this in smart contracts as well."
		},
		{
			"timestamps": {
				"from": "00:09:42,000",
				"to": "00:09:47,760"
			},
			"offsets": {
				"from": 582000,
				"to": 587760
			},
			"text": " So Aztec-Brettenberg back end does allow you to compile from a noir program to an Ethereum contract."
		},
		{
			"timestamps": {
				"from": "00:09:47,760",
				"to": "00:09:54,440"
			},
			"offsets": {
				"from": 587760,
				"to": 594440
			},
			"text": " Proving systems looking to integrate noir are going to have to provide their own implementation of how to generate a solidity verifier."
		},
		{
			"timestamps": {
				"from": "00:09:54,440",
				"to": "00:10:01,600"
			},
			"offsets": {
				"from": 594440,
				"to": 601600
			},
			"text": " Or if you choose to use any other smart contract platform, you're going to have to provide that implementation yourself if you're integrating a back end."
		},
		{
			"timestamps": {
				"from": "00:10:02,080",
				"to": "00:10:07,600"
			},
			"offsets": {
				"from": 602080,
				"to": 607600
			},
			"text": " This script here shows you how to generate a solidity verifier using that Aztec-Brettenberg back end."
		},
		{
			"timestamps": {
				"from": "00:10:07,600",
				"to": "00:10:25,080"
			},
			"offsets": {
				"from": 607600,
				"to": 625080
			},
			"text": " And it's important to take note though, if you change your circuit and don't change your, you don't regenerate your solidity verifier with this script, your circuit is ultimately going to fail as you're going to have a new Acer and you're going to need to regenerate that verifier in order to have accurate verification."
		},
		{
			"timestamps": {
				"from": "00:10:25,280",
				"to": "00:10:30,320"
			},
			"offsets": {
				"from": 625280,
				"to": 630320
			},
			"text": " And finally, we can actually have our Todam moment and verifier circuit and solidity."
		},
		{
			"timestamps": {
				"from": "00:10:30,320",
				"to": "00:10:38,000"
			},
			"offsets": {
				"from": 630320,
				"to": 638000
			},
			"text": " So using your favorite deployment method, you can deploy your turbo verifier as you would any other smart contract."
		},
		{
			"timestamps": {
				"from": "00:10:38,000",
				"to": "00:10:46,920"
			},
			"offsets": {
				"from": 638000,
				"to": 646920
			},
			"text": " And then you can take that proof that was spit out from Brettenberg in the exact same way with the public inputs prepended, pass it to the verifier."
		},
		{
			"timestamps": {
				"from": "00:10:46,920",
				"to": "00:10:54,120"
			},
			"offsets": {
				"from": 646920,
				"to": 654120
			},
			"text": " And if your public inputs are correct and you're specified your circuit correctly, it should ultimately return true."
		},
		{
			"timestamps": {
				"from": "00:10:54,520",
				"to": "00:11:02,840"
			},
			"offsets": {
				"from": 654520,
				"to": 662840
			},
			"text": " In the case of our private transfer, we're going to be checking, is that nullifier has been used before? Is the correct root?"
		},
		{
			"timestamps": {
				"from": "00:11:02,840",
				"to": "00:11:09,800"
			},
			"offsets": {
				"from": 662840,
				"to": 669800
			},
			"text": " And upon having a verified proof, we can actually then perform a private withdrawal."
		},
		{
			"timestamps": {
				"from": "00:11:09,800",
				"to": "00:11:12,720"
			},
			"offsets": {
				"from": 669800,
				"to": 672720
			},
			"text": " And that note, that will be entirely private."
		},
		{
			"timestamps": {
				"from": "00:11:12,720",
				"to": "00:11:19,720"
			},
			"offsets": {
				"from": 672720,
				"to": 679720
			},
			"text": " So that's it there. And you can see a more full example with the simple shield."
		},
		{
			"timestamps": {
				"from": "00:11:20,000",
				"to": "00:11:27,280"
			},
			"offsets": {
				"from": 680000,
				"to": 687280
			},
			"text": " But ultimately here, the benefit is that we can enable autonomous execution in contracts based off verification of noir circuits."
		},
		{
			"timestamps": {
				"from": "00:11:27,280",
				"to": "00:11:33,000"
			},
			"offsets": {
				"from": 687280,
				"to": 693000
			},
			"text": " And I want to also discuss some of the future work that we're going to be doing in noir."
		},
		{
			"timestamps": {
				"from": "00:11:33,000",
				"to": "00:11:36,680"
			},
			"offsets": {
				"from": 693000,
				"to": 696680
			},
			"text": " One of the main things that we want to add is verify proof."
		},
		{
			"timestamps": {
				"from": "00:11:36,680",
				"to": "00:11:44,720"
			},
			"offsets": {
				"from": 696680,
				"to": 704720
			},
			"text": " This will actually enable us to have recursive snarks inside of noir itself, which enables many more use cases than you can currently have."
		},
		{
			"timestamps": {
				"from": "00:11:45,800",
				"to": "00:11:57,400"
			},
			"offsets": {
				"from": 705800,
				"to": 717400
			},
			"text": " The wrapper itself is pretty new. And we want to improve this development tooling significantly to make it easier for anyone looking to integrate with noir."
		},
		{
			"timestamps": {
				"from": "00:11:57,400",
				"to": "00:12:08,120"
			},
			"offsets": {
				"from": 717400,
				"to": 728120
			},
			"text": " We also want to integrate it with repels, such as DK REPL. If you're familiar with that online, ID integrations, other debugging tools, a language server, lots of development tools to add."
		},
		{
			"timestamps": {
				"from": "00:12:08,640",
				"to": "00:12:26,760"
			},
			"offsets": {
				"from": 728640,
				"to": 746760
			},
			"text": " And in the medium to long term, we're going to be adding noir contracts. And noir contracts are going to be the next stage of Aztec's platform, where we'll actually have public and private state, which has its own challenges, which you can attend Mike Conner's talk at 230 from Aztec is going to be discussing that infrastructure."
		},
		{
			"timestamps": {
				"from": "00:12:26,760",
				"to": "00:12:35,760"
			},
			"offsets": {
				"from": 746760,
				"to": 755760
			},
			"text": " And how we actually are going to enable smart contracts in noir. If you have any questions, please shoot. And thank you."
		},
		{
			"timestamps": {
				"from": "00:12:35,760",
				"to": "00:12:38,760"
			},
			"offsets": {
				"from": 755760,
				"to": 758760
			},
			"text": " [APPLAUSE]"
		},
		{
			"timestamps": {
				"from": "00:12:38,760",
				"to": "00:12:45,760"
			},
			"offsets": {
				"from": 758760,
				"to": 765760
			},
			"text": " Thank you so much, Maxim. So we have two volunteers. There you go. That's where we're pulling through coming."
		},
		{
			"timestamps": {
				"from": "00:12:45,760",
				"to": "00:13:04,360"
			},
			"offsets": {
				"from": 765760,
				"to": 784360
			},
			"text": " Hey, good afternoon. Very impressive. Right now, how does your tooling work for this? You have to compile the noir contract and then deploy it into the layer two or the layer two test net or something."
		},
		{
			"timestamps": {
				"from": "00:13:04,440",
				"to": "00:13:21,840"
			},
			"offsets": {
				"from": 784440,
				"to": 801840
			},
			"text": " Not right now. That's the next iteration of Aztec's platform when we add the noir contracts. This is a purely ZK EVM DSL right now, where Aztec can generate that solidity verifier and you're going to be proving circuits on an EVM platform."
		},
		{
			"timestamps": {
				"from": "00:13:21,840",
				"to": "00:13:33,000"
			},
			"offsets": {
				"from": 801840,
				"to": 813000
			},
			"text": " You can generate-- like I showed in that example, you can compile your circuit and TypeScript, but you can also use our package manager, which I briefly mentioned to generate that intermediate representation,"
		},
		{
			"timestamps": {
				"from": "00:13:33,400",
				"to": "00:13:43,800"
			},
			"offsets": {
				"from": 813400,
				"to": 823800
			},
			"text": " that intermediate representation can be used the same way that it was used there. You just have to read it in from file using our wrapper methods."
		},
		{
			"timestamps": {
				"from": "00:13:43,800",
				"to": "00:13:53,960"
			},
			"offsets": {
				"from": 823800,
				"to": 833960
			},
			"text": " So you don't have to do anything extra for serialization that's handled by our wrapper. Yeah, right now. But you can verify without the EVM as well."
		},
		{
			"timestamps": {
				"from": "00:13:53,960",
				"to": "00:14:06,040"
			},
			"offsets": {
				"from": 833960,
				"to": 846040
			},
			"text": " You can just verify using TypeScript and you don't have to necessarily have a verification using a solidity contract that depends on your needs, but a lot of people like to have that autonomous execution."
		},
		{
			"timestamps": {
				"from": "00:14:06,040",
				"to": "00:14:13,880"
			},
			"offsets": {
				"from": 846040,
				"to": 853880
			},
			"text": " We have time for more questions. One over there in the left side, then we have two more here."
		},
		{
			"timestamps": {
				"from": "00:14:15,480",
				"to": "00:14:29,720"
			},
			"offsets": {
				"from": 855480,
				"to": 869720
			},
			"text": " Hey, hi. It was amazing. I wanted to ask, let's say, as a developer, I have the choice between Circum and Noir now, both as an end-user feature provide proof systems with Planck and Grot 16."
		},
		{
			"timestamps": {
				"from": "00:14:29,720",
				"to": "00:14:39,960"
			},
			"offsets": {
				"from": 869720,
				"to": 879960
			},
			"text": " That's exactly the same value proposition. So why would you say that we should experiment with Noir instead of just going with Circum? Sorry to put you in a position."
		},
		{
			"timestamps": {
				"from": "00:14:39,960",
				"to": "00:14:50,520"
			},
			"offsets": {
				"from": 879960,
				"to": 890520
			},
			"text": " No, no, no, it's okay. They do serve slightly different use cases. Circum is definitely much more low level. You're going to have to be specifying a lot of the constraints individually."
		},
		{
			"timestamps": {
				"from": "00:14:50,520",
				"to": "00:15:09,480"
			},
			"offsets": {
				"from": 890520,
				"to": 909480
			},
			"text": " While in the language, we specify those constraints for you. A basic example there, when I talked about if statements, you can constrain your on if statements. You don't have to use a multiplexer and things like that that make it just easier for the developer and kind of lower that barrier from someone who's maybe moving"
		},
		{
			"timestamps": {
				"from": "00:15:09,480",
				"to": "00:15:20,640"
			},
			"offsets": {
				"from": 909480,
				"to": 920640
			},
			"text": " from who's never coded ZK circuits before. And you can also constrain on data types outside of just our native type because everything that we have ultimately translates to that."
		},
		{
			"timestamps": {
				"from": "00:15:20,640",
				"to": "00:15:39,440"
			},
			"offsets": {
				"from": 920640,
				"to": 939440
			},
			"text": " And we do have, I know you can currently do Planck, but I believe right now, Noir is the only language that actually has truly fully integrated black box functionality where the proving system is specifying the custom gates and making those functions faster."
		},
		{
			"timestamps": {
				"from": "00:15:39,440",
				"to": "00:15:48,240"
			},
			"offsets": {
				"from": 939440,
				"to": 948240
			},
			"text": " Hi, why base Noir of Rust? Are there certain properties of Rust that make it a better language for this?"
		},
		{
			"timestamps": {
				"from": "00:15:48,240",
				"to": "00:15:58,600"
			},
			"offsets": {
				"from": 948240,
				"to": 958600
			},
			"text": " Well, we want to, one of the main focuses of Noir's safety and Rust, that same thing in Rust, right? And Rust is also just a nice language."
		},
		{
			"timestamps": {
				"from": "00:15:58,600",
				"to": "00:16:03,360"
			},
			"offsets": {
				"from": 958600,
				"to": 963360
			},
			"text": " Thanks a lot for the talk. I was wondering, do you have some tools for..."
		},
		{
			"timestamps": {
				"from": "00:16:03,360",
				"to": "00:16:05,200"
			},
			"offsets": {
				"from": 963360,
				"to": 965200
			},
			"text": " Wait, where am I looking? Sorry. I'm here."
		},
		{
			"timestamps": {
				"from": "00:16:05,200",
				"to": "00:16:12,200"
			},
			"offsets": {
				"from": 965200,
				"to": 972200
			},
			"text": " Oh, hey, hello. Thanks for the talk. Do you have some tools for testing the logic of the circuits?"
		},
		{
			"timestamps": {
				"from": "00:16:12,200",
				"to": "00:16:23,200"
			},
			"offsets": {
				"from": 972200,
				"to": 983200
			},
			"text": " Right now, it's essentially you're going to have to write your tests in TypeScript. We hope to add debugging tools. That's one of the main things that need to be added to make the tooling more effective."
		},
		{
			"timestamps": {
				"from": "00:16:23,200",
				"to": "00:16:30,200"
			},
			"offsets": {
				"from": 983200,
				"to": 990200
			},
			"text": " Yeah, you're going to have to essentially test it either in TypeScript. You can test it in Rust too and use the Nargo package manager."
		},
		{
			"timestamps": {
				"from": "00:16:30,200",
				"to": "00:16:36,200"
			},
			"offsets": {
				"from": 990200,
				"to": 996200
			},
			"text": " That's up to you, but I only highlighted TypeScript here because most contract developers are probably going to lean towards that."
		},
		{
			"timestamps": {
				"from": "00:16:36,200",
				"to": "00:16:43,200"
			},
			"offsets": {
				"from": 996200,
				"to": 1003200
			},
			"text": " Okay, thanks. We still have time for more questions. Five minutes more. There you go. On the right."
		},
		{
			"timestamps": {
				"from": "00:16:43,200",
				"to": "00:16:55,200"
			},
			"offsets": {
				"from": 1003200,
				"to": 1015200
			},
			"text": " Thank you. Just a quick question. On the first code sample you had, I could see the STD. The STD package was under a depth namespace. And I was wondering where that is."
		},
		{
			"timestamps": {
				"from": "00:16:55,200",
				"to": "00:17:07,200"
			},
			"offsets": {
				"from": 1015200,
				"to": 1027200
			},
			"text": " That's just our, I guess, native kind of dependencies. And that's how we do it. You can also import from GitHub or you can have modules as you would normally in Rust within your..."
		},
		{
			"timestamps": {
				"from": "00:17:07,200",
				"to": "00:17:16,200"
			},
			"offsets": {
				"from": 1027200,
				"to": 1036200
			},
			"text": " Where it would be like mod something. And you can also import packages from within a crate as well where it would be like crate this."
		},
		{
			"timestamps": {
				"from": "00:17:16,200",
				"to": "00:17:22,200"
			},
			"offsets": {
				"from": 1036200,
				"to": 1042200
			},
			"text": " And that would be the import. That's just how we import our standard library. Yeah, like Rust crates."
		},
		{
			"timestamps": {
				"from": "00:17:22,200",
				"to": "00:17:30,200"
			},
			"offsets": {
				"from": 1042200,
				"to": 1050200
			},
			"text": " Our Nargo, it's not like a copy of cargo, but it kind of mocks that functionality with crates and modules."
		},
		{
			"timestamps": {
				"from": "00:17:30,200",
				"to": "00:17:37,200"
			},
			"offsets": {
				"from": 1050200,
				"to": 1057200
			},
			"text": " So you can import modules from within your crate using use crate and then whatever else you'd like."
		},
		{
			"timestamps": {
				"from": "00:17:37,200",
				"to": "00:17:48,200"
			},
			"offsets": {
				"from": 1057200,
				"to": 1068200
			},
			"text": " It's a very nice talk. In the next phase of Aztec 3, can you talk about the process of converting existing circuits to NWR?"
		},
		{
			"timestamps": {
				"from": "00:17:48,200",
				"to": "00:17:58,200"
			},
			"offsets": {
				"from": 1068200,
				"to": 1078200
			},
			"text": " What do you mean existing circuits? Do you mean contracts? Like the... So in Aztec 3, you're planning on converting existing circuits to NWR, I assume?"
		},
		{
			"timestamps": {
				"from": "00:17:58,200",
				"to": "00:18:05,200"
			},
			"offsets": {
				"from": 1078200,
				"to": 1085200
			},
			"text": " So that's actually probably you'd want to go to Mike's talk to see more. It's very interesting how the infrastructure works."
		},
		{
			"timestamps": {
				"from": "00:18:05,200",
				"to": "00:18:16,200"
			},
			"offsets": {
				"from": 1085200,
				"to": 1096200
			},
			"text": " Essentially, though each function in the contract is going to be a circuit. But how that actually gets integrated into the system, you're going to have to attend Mike's talk to get more info on that. It's very interesting."
		},
		{
			"timestamps": {
				"from": "00:18:16,200",
				"to": "00:18:23,200"
			},
			"offsets": {
				"from": 1096200,
				"to": 1103200
			},
			"text": " We have someone from the team here as well. If you want to compliment anything, like to add on top of the conversation."
		},
		{
			"timestamps": {
				"from": "00:18:23,200",
				"to": "00:18:32,200"
			},
			"offsets": {
				"from": 1103200,
				"to": 1112200
			},
			"text": " Yeah, I just want to... So with Aztec 3, we're not actually trying to be ZK EVM compatible, right? It's a separate..."
		},
		{
			"timestamps": {
				"from": "00:18:32,200",
				"to": "00:18:33,200"
			},
			"offsets": {
				"from": 1112200,
				"to": 1113200
			},
			"text": " No."
		},
		{
			"timestamps": {
				"from": "00:18:33,200",
				"to": "00:18:35,200"
			},
			"offsets": {
				"from": 1113200,
				"to": 1115200
			},
			"text": " Right. Yeah, just making sure."
		},
		{
			"timestamps": {
				"from": "00:18:35,200",
				"to": "00:18:40,200"
			},
			"offsets": {
				"from": 1115200,
				"to": 1120200
			},
			"text": " Cool. There's one more over there, this site."
		},
		{
			"timestamps": {
				"from": "00:18:40,200",
				"to": "00:18:52,200"
			},
			"offsets": {
				"from": 1120200,
				"to": 1132200
			},
			"text": " Oh, yeah, that was my question again. He said they made a preamble to the question. So that means that NWR is going to target to EVMs."
		},
		{
			"timestamps": {
				"from": "00:18:52,200",
				"to": "00:18:58,200"
			},
			"offsets": {
				"from": 1132200,
				"to": 1138200
			},
			"text": " Aztec 3 is not going to be using NWR for its inter... for the circuits."
		},
		{
			"timestamps": {
				"from": "00:18:58,200",
				"to": "00:19:03,200"
			},
			"offsets": {
				"from": 1138200,
				"to": 1143200
			},
			"text": " So we're going to be using NWR for circuits, but you don't necessarily have to target the EVM there."
		},
		{
			"timestamps": {
				"from": "00:19:03,200",
				"to": "00:19:17,200"
			},
			"offsets": {
				"from": 1143200,
				"to": 1157200
			},
			"text": " We just, Aztec's back end does allow you to compile an EVM verifier from a NWR circuit, and that functionality will still exist, but NWR contracts and Aztec's platform are not going to be ZK EVM."
		},
		{
			"timestamps": {
				"from": "00:19:17,200",
				"to": "00:19:20,200"
			},
			"offsets": {
				"from": 1157200,
				"to": 1160200
			},
			"text": " They're going to be NWR."
		},
		{
			"timestamps": {
				"from": "00:19:20,200",
				"to": "00:19:28,200"
			},
			"offsets": {
				"from": 1160200,
				"to": 1168200
			},
			"text": " So, yeah, so that means that you also have the... you right now have to target for Aztec, or you are going to have... or you're going to build it yet."
		},
		{
			"timestamps": {
				"from": "00:19:28,200",
				"to": "00:19:30,200"
			},
			"offsets": {
				"from": 1168200,
				"to": 1170200
			},
			"text": " Sorry, can you say it again?"
		},
		{
			"timestamps": {
				"from": "00:19:30,200",
				"to": "00:19:42,200"
			},
			"offsets": {
				"from": 1170200,
				"to": 1182200
			},
			"text": " The TART, the compilation target right now, it's only EVM, but you are planning to be able to migrate to be able to compile as well to Aztec in the future. Yes."
		},
		{
			"timestamps": {
				"from": "00:19:42,200",
				"to": "00:19:54,200"
			},
			"offsets": {
				"from": 1182200,
				"to": 1194200
			},
			"text": " Yeah, so currently, NWR is just a language for creating circuits, and you can create a solidity verifier that allows you to verify those proofs on the on the theorem."
		},
		{
			"timestamps": {
				"from": "00:19:54,200",
				"to": "00:20:07,200"
			},
			"offsets": {
				"from": 1194200,
				"to": 1207200
			},
			"text": " Once we extend this index to have a contract terminology, Aztec free will be built, and it will have its own VM, and you can compile those contracts to the Aztec free VM, not the ZK EVM."
		},
		{
			"timestamps": {
				"from": "00:20:07,200",
				"to": "00:20:20,200"
			},
			"offsets": {
				"from": 1207200,
				"to": 1220200
			},
			"text": " Hi, hi, well, I am now in NWR right now. It's so new for me, and I would like to know whether the main applications that there are using NWR right now."
		},
		{
			"timestamps": {
				"from": "00:20:20,200",
				"to": "00:20:23,200"
			},
			"offsets": {
				"from": 1220200,
				"to": 1223200
			},
			"text": " The main applications using NWR right now? Yeah."
		},
		{
			"timestamps": {
				"from": "00:20:23,200",
				"to": "00:20:32,200"
			},
			"offsets": {
				"from": 1223200,
				"to": 1232200
			},
			"text": " Well, there hasn't been many. Mostly the examples you can find on my GitHub, or inside the NWR repo, testing the language."
		},
		{
			"timestamps": {
				"from": "00:20:32,200",
				"to": "00:20:44,200"
			},
			"offsets": {
				"from": 1232200,
				"to": 1244200
			},
			"text": " But there's anything you can think of where you would need to verify a proof, and do something based off that ZK proof, you couldn't theoretically do a NWR."
		},
		{
			"timestamps": {
				"from": "00:20:44,200",
				"to": "00:20:54,200"
			},
			"offsets": {
				"from": 1244200,
				"to": 1254200
			},
			"text": " So that can be quite a lot of things, anonymous proof of membership, private games on public blockchains, lots of different things."
		},
		{
			"timestamps": {
				"from": "00:20:54,200",
				"to": "00:20:58,200"
			},
			"offsets": {
				"from": 1254200,
				"to": 1258200
			},
			"text": " All right, big round of applause to Maxime from Aztec."
		},
		{
			"timestamps": {
				"from": "00:20:59,200",
				"to": "00:21:01,200"
			},
			"offsets": {
				"from": 1259200,
				"to": 1261200
			},
			"text": " [music]"
		},
		{
			"timestamps": {
				"from": "00:21:01,200",
				"to": "00:21:06,200"
			},
			"offsets": {
				"from": 1261200,
				"to": 1266200
			},
			"text": " [silence]"
		},
		{
			"timestamps": {
				"from": "00:21:06,200",
				"to": "00:21:11,200"
			},
			"offsets": {
				"from": 1266200,
				"to": 1271200
			},
			"text": " [silence]"
		},
		{
			"timestamps": {
				"from": "00:21:11,200",
				"to": "00:21:40,200"
			},
			"offsets": {
				"from": 1271200,
				"to": 1300200
			},
			"text": " [ Silence ]"
		}
	]
}
